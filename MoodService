local DEBUG = false
local function debugLog(...)
	if not DEBUG then return end
	print(...)
end

local DEBUG2 = true
local function debugLog2(...)
	if not DEBUG2 then return end
	print(...)
end

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MoodDefs = require(ReplicatedStorage.BodySystem.MoodDefs)

local SortedCategories = {} -- отсортированный список категорий по приоритету

for name, category in pairs(MoodDefs) do
	table.insert(SortedCategories, {
		name = name,
		data = category,
		priority = category.priority or 0
	})
end

table.sort(SortedCategories, function(a, b)
	return a.priority > b.priority
end)

local MoodService = {}

MoodService.MoodsEvaluated = Instance.new("BindableEvent")
MoodService.MoodAdded = Instance.new("BindableEvent")
MoodService.MoodRemoved = Instance.new("BindableEvent")

function MoodService:Evaluate(player, body)
body.Moods = body.Moods or {}
body.ActiveMoods = body.ActiveMoods or {}

	debugLog("[EVAL START] body:", body, "Hunger=", body.Hunger, "Thirst=", body.Thirst, "Pain=", body.Pain)

	for _, entry in ipairs(SortedCategories) do
		local categoryName = entry.name
		local category = entry.data
		
	local previousMoodId = body.Moods[categoryName]
	local newState = nil

	-- ищем активное состояние категории
		for _, state in ipairs(category.states) do
			local ok = false
			-- вызываем condition один раз и запоминаем результат
			local success, res = pcall(function() return state.condition(body) end)
			if not success then
				debugLog("[EVAL][ERROR] state.condition threw:", categoryName, state.id, res)
			else
				ok = res and true or false
			end

			debugLog("[EVAL CHECK]", categoryName, "state:", state.id, "->", ok, " (thirst=", body.Thirst, " hunger=", body.Hunger, ")")

			if ok then
				newState = state
				break
			end
		end

	local newMoodId = newState and newState.id or nil
	
		debugLog("[EVAL RESULT]", categoryName, "previous:", previousMoodId, "new:", newMoodId)

	-- ЕСЛИ НИЧЕГО НЕ ИЗМЕНИЛОСЬ — ПРОПУСКАЕМ
	if previousMoodId == newMoodId then
		continue
	end
	
		debugLog("[EVAL REMOVE CHECK]", categoryName, "previousMoodId:", previousMoodId)

	-- УБИРАЕМ СТАРЫЙ МУД
	if previousMoodId then
		body.ActiveMoods[previousMoodId] = nil

		MoodService.MoodRemoved:Fire(body, previousMoodId)

		debugLog("[MOOD REMOVED]", categoryName, previousMoodId)
	end

		debugLog("[EVAL ADD CHECK]", categoryName, "newState:", newState and newState.id or "<nil>")

	-- ДОБАВЛЯЕМ НОВЫЙ
	if newState then
		body.Moods[categoryName] = newMoodId
		body.ActiveMoods[newMoodId] = {
			category = categoryName,
			displayName = newState.displayName,
			description = newState.description,
		}

		MoodService.MoodAdded:Fire(body, newMoodId, body.ActiveMoods[newMoodId])

		debugLog("[MOOD ADDED]", categoryName, newMoodId)
	else
		body.Moods[categoryName] = nil
		
	end
		debugLog2("=== SORTED CATEGORIES ===")
		for i, entry in ipairs(SortedCategories) do
			debugLog2(i, entry.name)
		end
		debugLog2("=========================")
  end
	MoodService.MoodsEvaluated:Fire(body) 
end
      
return MoodService
